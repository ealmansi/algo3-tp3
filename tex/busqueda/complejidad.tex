Antes de comenzar el análisis de complejidad vamos a aclarar lo siguiente:

En este algoritmo usamos la estructura Camino, que es una lista de ejes y además tiene el peso total $W_1$ y $W_2$. Y además usamos la estructura vecino, que tiene tres tipos: $TIPO1$ significa que es un vecino que surge de eliminar un nodo de la solución actual, $TIPO2$ que surge de agregar un nodo, o $TIPO3$, que surge de cambiar un nodo por otro. Además la estructura tiene una posición donde hay que hacer los cambios para pasar del camino actual al vecino (estos cambios se deducen según el tipo del vecino que sea). Por último la estructura cuenta con una lista de nodos a agregar al camino actual, si se cambia o agrega un nodo la lista tendrá un elemento y si se elimina un nodo la lista será vacía.

Utilizamos esta estructura para poder pasar de un camino a su vecino en una complejidad constante $O(1)$ ya que ésta cuenta con la información necesaria para saber cuáles son los cambios a realizar y dónde hay que realizarlos. Si no contáramos con esta estructura y tuviésemos simplemente otro camino deberíamos copiar el camino para actualizar la solución, lo que tendría una complejidad temporal lineal.

Dicho esto pasamos a analizar la complejidad de los algoritmos que buscan vecinos.

$\bullet$ buscarVecinoAgregar

Primero vale aclarar que en la linea $3$ del pseudocódigo decimos que la complejidad de la guarda del $For$ $j \in adyacentes(mejorSol_i,G) \cap adyacentes(mejorSol_{i+2},G)$ es $O(n)$ esto es así porque lo que hacemos esver que $j$ este tanto en $adyacentes(mejorSol_i,G)$ como en $adyacentes(mejorSol_{i+2},G)$, y ambas operaciones son $O(n)$. Si realmente hicieramos una intersección de conjuntos la complejidad sería otra.

Aclarado esto, la complejidad del algoritmo buscarVecinosAgregar es la siguiente:

$O(1) + n*(n*(O(n) +4*O(1))+O(1))$

Por álgebra de órdenes:

$n^2(O(2n+4))$

$O(2n^3+4n^2)$

$O(n^3)$

$\bullet$ buscarVecinoQuitar

Esta vez, en el $For$ usamos la operacion $j \in adyacentes(mejorSol_i, G)$ que también tiene complejidad lineal.

La complejidad del algoritmo es la siguiente:

$O(1)+n*(O(1)+O(n)+5*O(1))$

Por álgebra de órdenes:

$O(1)+O(n)+O(n^2)+5*O(n)$

$O(n^2+6n+1)$

$O(n^2)$

$\bullet$ buscarVecinoCambiar

Las operaciones utilizadas en este algoritmo son las mismas que utilizamos en el algoritmo anterior. Por lo tanto, las justificaciones son las mismas.

La complejidad del algoritmo es la siguiente:

$O(1) + n*(n*(O(n) +4*O(1))+O(1))$

Por álgebra de órdenes:

$n^2(O(2n+4))$

$O(2n^3+4n^2)$

$O(n^3)$

Ahora pasamos a analizar la complejidad del algoritmo de búsqueda local.

En este algoritmo no sabemos a priori cuantas veces se va a iterar en la búsqueda de vecinos. Como necesitamos que la complejidad sea polinomial (es uno de los objetivos de hacer una heurística) limitamos la cantidad de iteraciónes a una variable $c$ esta variable podría valer $n$, $n^2$ o cualquier otro valor que permita que la complejidad del algoritmo en el peor caso sea polinomial.

La complejidad del algoritmo es la siguiente:

$O(1)+c*(2*O(n^3)+O(n^2)+4*O(1))$

Por álgebra de órdenes:

$O(c(2n^3+n^2+O(1)))$

$O(cn^3)$