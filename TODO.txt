General:
Parece ser que el problema no es solo con numeros enteros, sino solo las entradas q nos dan.
O sea solo la parte implementativa pero lo demas deberia ser R.

Exacto:
  NADA

Goloso:
. análisis de calidad
  - dibujo

Busqueda Local:
. análisis de la calidad de las soluciones (completo)
  - justificar por qué la familia de grafos que usamos para el goloso también rompe busqueda local
  - Describir encontrar una familia de grafos que rompa el goloso pero se arregle con búsqueda local
. experimentación
  - probar variantes para la semilla: goloso o dijkstra sobre W1
  - decir porque es mejor con el goloso que con dijkstra
. concluir cuál es la mejor configuración

Grasp:
. experimentación:
  - hay que ver qué pasa modificando:
    > coef_rand
    > max_cant_it_sin_mejora
    > epsilon
    > tipo de semilla (goloso o dijkstra sobre W1)
  - gráficos comparativos de tiempo y calidad de soluciones
. concluir cuál es la mejor configuración

Comparación entre todos:
  . comparar tiempo y calidad entre la mejor configuración de goloso, busqueda local y grasp


---------------------


1-El metodo de parada de busqueda local y grasp no hay q acotarlo por n o nada parecido.
Para calcular la complejidad decimos algo asi como O((ciclo)*(cant_iteraciones)). donde no
sabemos q mierda es cant_iteraciones

2-Podemos acotar cantidad de iteraciones en el caso de enteros por el camino max.

3- Altamente recomendado probar otro goloso (Dijkstra sobre W_1)

Grasp:
1- Idem busqueda local 1. Seria algo asi como O(cant_it * O(Busqueda Local))

2- Altamente recomendado probar con el dijkstra random solo y con el dij rand metido en el goloso y comparar

3- Otra cosa que podemos probar es las dos versiones de dij rand (k mejores o a k de distancia del mejor).

Familias:

1- Escribir en base a como rompe la familia el algoritmo, como podria solucionarse o xq no se puede (es dificil).
